# 변수

프로그램에서 데이터의 값들이 일시적으로 저장되는 공간을 변수라고 한다.
변수에 담겨있는 데이터들은 컴퓨터의 전원을 끄면 사라지기 때문에 데이터를 영구적으로 저장하려면 보조기억장치에 저장하여야 한다.

### 변수는 물리적으로 컴퓨터의 어느 공간에 만들어지는 것일까?
> 메인 메모리에 만들어진다. 메인메모리는 ram과 같은 메모리를 의미한다.

만약 변수를 사용하지 않고 데이터를 저장하려면 메모리의 주소를 가지고 데이터를 저장해야된다.
다만, 우리는 변수라는 개념을 사용할 수 있기 때문에 특별한 경우를 제외하고는 메모리를 주소로 접근할 필요가 없다.

### 상수는 무엇일까?
> 변수와 다른 변경될 수 없는 데이터이다. 프로드램이 실행되는 동안에 값이 변경되지 않는다.

### 상수는 어디에 저장될까?
> 변수는 메인메모리에 만들어지는건 방금 정리하였음. 컴퓨터에서 계산을 하기 위해서는 메모리에 필수적으로 저장이 되어있어야하는데,
마찬가지로 상수도 메모리에 저장이 된다. 다만, 변경이 불가능하다는 태그가 같이 있다. 

3.121235과 같은 상수에는 이름이 붙지 않는다. 이러한 상수를 __리터럴 상수__ 라고하고 상수에도 이름을 붙힐 수 있는 방법은 있다. 이를 __기호 상수__ 라고한다.

----
## 변수의 자료형
데이터의 종류애 따라서 할당해주는 용량이 달라야 효율적인 계산 및 관리가 되기 떄문에, 변수에 자료형이 존재한다. 
이 데이터의 종류를 __자료형__ 또는 __데이터 타입__ 이라고한다.

자료형을 나누면 아래와 같다.
+ 정수형 (integer type)
+ 부동 소수점형 (floating-point type)
+ 문자형 (character type)

### 정수형
> 정수 타입의 데이터를 저장할 수 있다.
short, int, long 등이 있다.

### 부동 소수점형
> 실수 타입의 데이터를 저장할 수 있다.
float, double, long double이 여기에 속한다.

### 문자형
> 하나의 무자를 저장할 수 있다. char형이 속함.


    자료형의 크기를 알아보기위해선 sizeof() 연산자를 이용하면 된다.

ex) sizeof(변수) : 이는 변수가 가진 자료형의 크기를 나타내준다.

---

## 변수의 이름 짓기

### 식별자
변수는 반드시 이름이 있어야하고, 이름을 짓기 위해서는 몇 가지의 규칙을 자켜줘야한다. 이를 식별자라고 부른다.

식별자는 다음에 따라 만들어야한다.
- 영문자와 숫자, _로 이루어진다.
- 식별자의 중간에 공백이 들어가면 안된다.
- 식별자의 첫 글자에는 반드시 영문자 또는 _이어야 한다. 숫자로 시작 불가능.
- 대문자와 소문자는 구별된다.
- c언어의 키워드와 똑같은 식별자는 허용되지 않는다.

### 키워드란?
> __예약어__ 라고도 하며 키워드는 사용자가 다시 정의하거나 사용하는 것이 금지된 고유한 의미를 가지고 있는 특별한 단어이다.
ex) auot, return, char, int ,long, typedef, struct 등등

---

## 변수의 선언과 사용

    변수의 선언은 반드시 함수의 시작 부분에서 선언되어야 한다. 이를 지키지 않는다면 컴파일 오류가 발생한다.
    다만 요즘은 어디에서든지 변수를 선언할 수 있다.

---

## 정수형
정수형에는 다음의 타입이 존재한다. short(2byte), int(4byte), long(4byte), (long long(8byte))
여기에 부호가 없는 자료형은 각 정수형 앞에 unsigned를 붙인다.

#### short
- 2바이트가 할당되는 정수의 자료형이다.
- 저장가능한 범위는 -32768~32767 이다.(부호가 존재 할 경우)
- 부호가 없다면 저장가능한 범위는 0~65535이다.

#### int
- 4바이트가 할당되는 정수의 자료형이다.
- 저장가능한 범위는 -2^(8*4-1=31)~ 2^31-1, 부호가 없을 경우 0~2^32-1
- 이는 -21억에서 21억정도를 표현할 수 있다고 보면된다.

#### long
- 4바이트가 할당되는 정수의 자료형이다.
- 저장능한 범위는 int와 같다.

만약 변수가 양수만을 사용한다면, unsigned을 같이 선언해주어서 변수 범위를 키울수도 있다.

    만약, printf()함수에서 unsigned을 선언하지 않은 변수에서 값이 허용량보다 커지면 음수가 등장한다!
    따라서 반드시 unsigned의 경우에는 %u를 사용하자.

### 오버 플로우(over flow)

정수형 변수가 나타낼 수 있는 정수의 범위가 제한되어 있기 때문에 생기는 한 가지 상황.
산술 연산 결과가 정수형이 나타낼 수 있는 범위를 __넘어갈 때__ 일어나는 상황이다.

> 만약 short형 정수에서 최대치는 32767인데, 여기에서 + 1을 할경우 -32768이 출력된다.

    정수형에서 overflow가 발생하더라도 컴파일러는 아무런 경고를 하지 않기 때문에, 결과값이 이상하면 확인해봐야한다.

### 정수 상수

정수인 상수는 기본적으로 int형으로 간주된다.그러나 만약, int형의 범위를 넘는 상수는 컴파일러가 알아서 long형으로 취급한다. 만약 long으로도 안되면
unsigned 형으로 변경될 수 있다. 컴파일러는 상수값을 처리할 때 가능한 자료형중에서 가장 작은 자료형을 선택한다.

만약 상수의 자료형을 프로그래머가 직접 명시적으로 지정하고 싶은 경우는 그렇게 할 수도 있다.
예를들어 123L처럼 정수인 상수 뒤에 접미사로 L을 붙이면 123이라는 상수를 long형으로 간주한다.

정수 상수는 10진법뿐만 아니라 8진법이나 16진법으로도 표기가 가능하다. 8진법으로 표기하려면 앞에 0을 붙이면 된다. 8진법 상수는 0에서 7까지의 숫자를 포함할 수 있다. 즉 10을 8진법으로 표기해보면 012가된다.

    printf()를 사용하면서 수식의 값을 8진법이나 16진법으로 출력하려면 각 %o와 %x를 사용한다. 8진수 앞에 0을 붙여서 출력하려면 %#o를 사용한다. 16진수 앞에 0x를 붙여서 출력하려면 %#x를 사용한다.
    ex) printf("%#x", 0x10); 이 코드는 0x10와 같은 형태로 출력한다.


### 기호 상수(literal constant)
보통의 상수에는 변수왖는 달리 이름이 없다. 그러나 상수에도 이름을 붙일 수 있다. 기호 상수는 기호에 의하여 상수를 표현 한 것이다.

기호 상수는 실제 값을 그대로 쓰는 방법애 비하여 몇 가지 장점을 지닌다.
- 기호상수를 사용하면 프로그램을 읽기가 쉬워진다.
- 기호상수를 사용하면 상수의 값을 변경하려고 하는 경우에 쉽게 할 수 있다.

### 기호상수의 정의 방법

#### 1. #define 문장 사용

형식 : #define 기호상수 값
설명 : 값을 나타내는 기호 상수를 정의한다.
예 : #define EXCHANGE_RATE 1120  >> EXCHANGE_RATE를 1120인 기호상수로 정의한다.

##### 2. const 키워드 사용
형식 : const 자료형 변수이름 = 초기값
설명 : const를 사용하면 값을 변경할 수 없는 변수를 정의할 수 있다.
예 : const int EXCHANGE_RATE = 1120; >> EXCHANGE_RATE를 1120인 기호상수로 정의한다.



#### 위의 2가지 방법중 어떤 것이 좋을까?
> 일반적으로 const 방법을 사용하여 상수를 만드는 편이 좋다. 이는 자료형도 지정할 수 있으므로, 문법적인 여러 검사도 가능하다.
추가로 배열이나 구조체와 같은 복합 데이터 타입에서도 const는 사용할 수 있다.

---

### 내부적인 정수 표현 방식

컴퓨터 안에서는 모든 것을 이진수로 표현한다. 따라서 정수도 0과 1의 조합으로 나타낼 것이다. 이진수의 하나의 자릿수를 Bit라고 한다.
이때, Bit는 ON과 OFF라는 상태를 가지는 스위치로 생각하면 된다. 비트가 많아지면 어떤 정수도 나타낼 수 있다.

10진수를 2진수로 변환하는 방법
- 주어진 수를 2로 나누어서 몫과 나머지를 기록한다.
- 몫이 1 아니면 위의 과정을 되풀이한다.
- 몫이 1이면 마지막 단계의 몫과 나머지들은 역순으로 기록하면 된다.
- 몫이 1이면 마지막 단계의 몫과 나머지들을 역순으로 기록하면 된다.

이런식으로 컴퓨터는 정수를 2진수로 표현하서 나타내는데, 정수에는 양뿐아니라 음의 정수도 존재한다. 그에따라 보통은 최상위 비트를 부호 비트로 사용한다.(sign bit) 부호 비트가 0이면 양의 정수, 1이면 음의 정수를 나타낸다. 이는 연산을 할때 유의미한 의미를 갖는다. (보수의 개념)

음수를 만드는 법
- 주어진 수를 2진수로 표현한다.
- 2진수로 변환된 정수의 0과 1을 반전시킨다.
- 1을 더해준다.

따라서  0101인 경우 -5는 1011이다. 이렇게 되어야
5 + -(5) 인 경우 0000이 되어 0이 된다.

#### 보수의 정의
> 보수는 거스름돈과 같은 개념이다. 10원을 내고 3원짜리 물건을 산다면, 7원이 남게된다. 이 7원이 10의 보수가 되는 것이다.
따라서 2진수에서의 1의 보수는 1을 제한 남는 수는 1이기 때문에 2진수에서의 1의 보수는 1이다.
마찬가지로 10진법에서의 1의 보수는 9이다.

---

### 부동 소수점형

#### 컴퓨터에서 실수를 나타내는 방법 

우선적으로, 정수 부분과 소수 부분을 위하여 각각 일정 비트를 할당하는 방법을 통해 컴퓨터는 실수를 나타낸다. 이는 _고정 소수점_ 방식이라고 한다.
정수부분은 상위 비트에 저장되고 소수부분은 하위 비트에 저장된다.
이는 간단하고 알기 쉽다는 장점이 있지만, 아주 큰 수를 표현할 수 없다는 결함이 존재한다.

이에 따라서 큰 실수를 처리할 수 있도록 등장한 방식이 __부동 소수점__ 방식이다.
이는 소수점의 위치가 떠서 움직인다는 뜻이다. (to부정사의 부정과 같은 뜻) 따라서 소수점의 위치가 움직이므로, 정밀도를 보다 높게 표현할 수 있다
즉, 고정 소수점 방식에 비해 아주 큰 정수와 아주 작은 수의 소수의 표현이 가능하다. 부동 소수점 방식은 실수를 가수와 지수 부분으로 나누어서 표현하는 것이다.
가수 부분은 실수의 정밀도를 나타내고 지수 부분은 실수값의 범위를 결정한다.

ex) 24 e^21 와 같은 표기방법을 사용한다는 것이다.

|부호 비트 | 가수 부분 | 지수 부분|
|:---:|:---:|:---:|
|1Bit|23Bit|8Bit|

위와같이 가수와 지수를 따로 표현하게 되면 표현할 수 있는 실수의 범위가 대폭 늘어난다. 32비트를 위와같이 나누어서 표현하게 되면 가수 부분은 6자리의 십진수로 표현이 가능하고 지수부분은 10^38 승까지 표현이 가능해진다.

다만 부동 소수점 방식은 고정 소수점 방식에 비해 계산 속도가 느리기 때문에, 부동 소수점 장치가 CPU혹은 별도로 포함되어 있는 경우가 많다.
또한 부동 소수점 방식은 정확하게 맞아떨어지지 않고 어느정도의 오차가 생길수 밖에 없기 때문에 가수부분이 늘어날수록 정밀도는 늘어난다.

#### 부동 소수점 자료형

float : 단일 정밀도 부동 소수점
가장 빠른 표현 방식
8비트는 지수부분 나머지는 가수부분으로 사용한다.
float의 경우 실수에서의 소수점 6번째 자리수까지만 정확하게 나타낼 수 있다.
32비트를 갖는다.

double, long double : 두배 정밀도 부동 소주점
11비트가 지수, 나머지는 가수부분으로 사용한다.
대략 유효숫자는 16자리까지이다.
64비트를 갖는다.

#### 실수를 출력하는 형식 지정자

실수를 출력하는 기본적인 형식 지정자는 %f이다. 실수를 출력시킬 때 기본적으로 소수점 6자리까지만 출력된다. 따라서 출력하고자 하는 시루가 소수점 6자리를 넘으면 반올림된다.

실수를 출력할 때, 소수점 이하 자리수를 제한하려면 %10.3f와 같이 적어주어야 한다. 이는 전체 10자리 중에서 소수점이하를 3자리로 하라는 것을 의미한다.

실수를 지수 표기법으로 출력하려면 %e나 %E를 사용한다. %g는 실수를 출력할 때 6자리 안에서 표현이 가능하면 %f방식, 그렇지 않으면 %e방식을 사용하게 된다.

> float 같은 실수를 int 같은 정수에 넣을 경우 : 컴파일러는 경고를 해주지만, 정수부분만 대입되는 경우가 있을 수 있음.

#### 부동 소수점 상수

부동 소수점 상수는 기본적으로 double형으로 저장되고 4바이트의 float형을 만들려면 실수 상수 끝에 f,F를 붙여주면 된다.

부동 소수점 상수는 지수 표기법으로도 표현이 가능하다. 지수 부분을 e나 E로 표기한다.
따라서 실수를 입럭할 때 3.14가 아니라 3.14e^0으로도 표기가 가능하다.

> 추가로, 2는 정수 상수이고 2.0은 부동 소수점 상수이다. 이는 분명히 다른데, 컴퓨터는 정수의 연산과 실수의 연산을 다르게 두기 때문에 분명히 구분해줘야한다.

---

실수에서는 overflow 뿐아니라 underflow도 존재한다. 주의하길 바란다. 다만 정수와는 다르게 overflow가 발생하면 컴파일러가 경고를 해준다.
추가로, 출력은 무한의 의미인 INF를 출력한다.


부동 소수형을 사용할 경우

> 계산해야하는 실수의 크기가 매우 크거나 작을 경우는 정밀성이 매우 떨어진다. float의 경우 6자리, double의 경우 16자리가 유효한 의미를 갖는데, 이를 초과할 경우 계산이 정확하게 이루어지지 않을 수 있다.

---

### 문자형

c에서는 기본적으로 아스키 코드로 표준 규격을 맞추었다.
char형으로 문자를 저장할 때는 작은따옴표를 사용하여 문자를 저장한다.

#### 제어 문자

아래는 이스케이프 시퀀스

|제어 문자| 이름 | 의미
|--|:--|--|
|\0|널 문자||
|\a|경고|"삐" 하는 경고음 발생|
|\b|백스페이스|커서를 현재의 위치에서 한글자 뒤로 옮긴다.|
|\t|수평 탭|커서의 위치를 현재 라인에서 설정된 다음 탭 위치로 옮긴다.|
|\n|줄 바꿈|커서를 다음 라인의 시작 위치로 옮긴다.|
|\v|수직 탭|설정되어 있는 다음 수직 탭 위치로 커서를 이동|
|\f|폼피드|주로 프린터에서 강제적으로 다음 페이지로 넘길 때 사용된다.|
|\r|캐리지 리턴||
|역슬래시"|큰따옴표|원래의 큰따옴표 자체|
|역슬래시'|작은따옴표|원래의 작은따옴표 자체|
|역슬래시 2개|역슬래시|원래의 역슬래시 자체|

#### char 정수형

char형은 사실 8비트의 정수를 저장하는 자료형이다. 따라서 문자 뿐만 아니라 작은 정수 값다 저장할 수 있다.
char형은 시스템에 따라서 구현이 약간 달라지는데, 일반적으로 char형은 부호가 있는 자료형으로 간주되지만 아닌 시스템도 존재한다.

이 사실은 다음과 같은 경우에서 유의미하다.

char code = 'A';

printf("%d %d %d \n", code, code +1 , code+2); : 65 66 67
printf("%c %c %c \n",code, code+1, code+2); : A B C 가 출력된다.

char로 저장한 문자가 문자형 출력 지정자를 사용하면 아스키 코드에 저장된 번호에 해당하는 문자자체를 출력하고
정수형 지정자를 사용하면 아스키 코드에 저장된 번호에 해당하는 문자를 숫자로 변환하여서 출력한다.


---

## vscode에서의 c언어

sizeof에서 확인한 사실은 long 형도 8바이트를 할당한다는 사실이다.
따라서 long과 long long 사이의 구분은 크게 필요없고 출력 지정자를 어떻게 설정하는지에 따라 오버플로우의 의미가 달라진다.


또한 scanf()로 입력할때 double을 입력하기위해선 %lf을 설정하는것 처럼
long을 출력하기 위해선 %ld가 필요하고
long long을 출력하기 위해선 %lld를 설정해주어야한다.

다만 long과 long long 둘다 %d에서 출력을하면 4바이트에서 발생하는 오버플로우가 발생하고 출력지정자를 %ld로 높여주면 해당 상황에서 오버플로우가 발생하지 않는다.

추가로 long 변수에 int 변수의 값을 넣어주면 
ex) int test_1 = 4비트에서 오버플로우 발생값;
    long test_2 = test_1

을 넣어주고 각각 %d, %ld로 출력하면 똑같이 오버플로우가 발생한다. 따라서 대입받는 변수의 자료형크기가 크더라도 대입하는 변수의 자료형 크기가 작으면 작게 받아진다.
이때, 자료형이 작아지는 건 아니기 때문에, 그냥 long자료형은 ld로 출력하면 맘편하고, int 자료를 long에 넘겨줄때만 조심하면 된다.


----

## 8진수, 16진수를 다룰때

prinf()를 사용할때 기본적인 8진수, 16진수를 출력하기 위해선 %d가 아닌 %o(8진수), %x(16진수를 사용해야한다.

    예를들어    int x = 11; printf("%d, %o, %x", x,x,x);라면 11, 38,B가 출력될것이다.

추가로 8진수, 16진수 앞에 0을 붙이고 싶을떄는 %#x, %#o 이런식으로 붙여주면 된다.
그리고 이 진수들 앞에 일정 개수 이상의 자리를 표현하고 싶을때는 #대신 0+숫자를 넣어주면 된다. ex) %08x : 8자리로 16진수 출력, %08o : 8자리로 8진수 출력
출력필드의 크기를 지정해준다고 생각하면된다.

scanf()를 사용할 때는 마찬기지로 8진수로 입력받을거면 %o, 16진수로 입력받을거면 %x를 %d대신에 지정해주면 된다.

