# 수식과 연산자

## 수식과 연산자의 개념

### 수식
피연산자들과 연산자의 조합.
피연산자는 숫자들이고, 연산자들은 기호이다.

### 연산자의 분류

연산자는 기능에 따라 다음과 같이 분류가 가능하다. 또한 피연산자의 수에 따라 단항, 이항, 삼항 연산자로 나누어진다.

|연산자의 분류|연산자|의미|
|---|---|---|
|대입|=|오른쪽을 왼쪽에 대입|
|산술|+, -, *, /, %|사칙연산과 나머지 연산|
|부호|+, -|양수와 음수 표시|
|증감|++, --|증가, 감소 연산|
|관계|>, <, ==, !=, >=, <=|오른쪽과 왼쪾을 비교|
|논리|&&, 싀프트 역슬래시 * 2 ,!|논리적인 AND, OR, NOT|
|조건|?|조건에 따라 선택|
|콤마|,|피연산자들을 순차적으로 실행|
|비트 단위 연산자|&, 쉬프트 역슬래시, ^, ~, <<, >>|비트별 AND, OR, XOR, 반전, 이동|
|sizeo연산자|sizeof|자료형이나 변수의 크기를 바이트 단위로 변환|
|형 변환|(type)|변수와 상수의 자료형을 변환|
|포인터 연산자|*, &, []|주소 계산, 포인터가 가리키는 곳의 내용 추출|
|구조체 연산자|. , ->|구조체의 멤버 참조|


---

## 산술 연산자

> 나눗셈 연산을 할 때, 정수와의 계산과 실수와의 계산은 다른 결과를 불러온다. 실수의 계산이 소수점을 계산함으로 더 정확하다.
예를들어 7/4는 1.75인데 이를 정수형 변수들로 연산할 경우 소수점은 버려진다. 따라서 실수형 변수들을 사용해줘야한다.

### 산술 연산자

기본적인 산술연산자인 덧셈, 뺄셈, 곱셈, 나눗셈, 나머지 연산이 존재한다.
설명은 이하 생략.

### 부호 연산자

변수나 상수의 부호를 나타내거나 변경하는 연산자이다. 자주 쓰는 "-" 가 존재한다.
이하 생략

### 증감 연산자

++, --가 존재하는데, 이 연산자가 피연산자의 앞, 뒤에 있냐에 따라 연산의 순서가 달라진다.

- 만약 증감 연산자가 앞에 위치한다면 함수에서 연산을 할 때, 제일 먼저 해당 피연산자에 대해 증감한다.
- 마찬가지로 증감 연산자가 뒤에 위치한다면 연산을 할 때, 모든 연산이 끝난 후에 증감한다.

예를들어
int x = 10;
y = x++;
y = ++x;

위를 가정하면, 첫번째 문장은 x = 11, y = 10이고 두번째 문장은 x = 11, y =11이다.
두번째 문장에선 우선적으로 증감이 적용되어서 x = x + 1 이후 y = x가 적용되었고,
첫번째 문장에선 후순위로 중감이 적용되어서 y = x 이후 x = x + 1이 적용되었다.

--- 

## 대입 연산자

기본적인 대입 연산자에 대한 설명 이하생략.

### 복합 대입 연산자.

|복합 대입 연산자|의미|
|--|--|
|x += y|x = x + y|
|x -= y|x = x - y|
|x *= y|x = x * y|
|x /= y|x = x / y|
|x %= y|x = x % y|
|x &= y|x = x & y|
|x (OR)= y|x = x (OR) y|
|x ^= y|x = x ^ y|
|x >>= y|x = x >> y|
|x <<= y|x = x << y|


---

## 형 변환

int형의 값이 double형의 값으로 변환되는 것과 같은, 데이터의 형이 변환되는 것을 의미한다. 형변환은 크게 2가지로 나뉘는데,
우선적으로 컴파일러에 의하여 자동으로 형변환이 이루어지는 것과, 프로그래머가 명시적으로 데이터의 형을 변환하는 것이다.

### 대입 연산시 자동적인 형 변환

우선적으로 3가지 경우로 나뉜다.
- 대입 연산시 형 변환
- 정수 연산시 형 변환
- 수식 연산시 형 변환


우선적으로, 대입 연산시 형 변환은 올림 변환과 내림 변환으로 나뉘는데,
>실수형 변수에 정수를 대입하면, 자동적으로 정수가 실수형식으로 바뀌는게 올림 변환

>정수형 변수에 실수를 대입하면, 자동적으로 실수가 정수형으로 저장되어 소수점을 버리는게 내림 변환

정수 연산시의 형 변환은 만약, char형과 short형의 연산이 이루어진다고 치면, 컴파일러는 이 두 변수의 결과가 자동적으로 int형으로 바꾼 후 출력된다.

>int형은 cpu가 처리할 수 있는 가장 이상적인 크기이기 때문이다.

수식 연산시 형 변환

원칙적으로 수식의 피연산자로는 동일한 자료형만을 사용하여야 하는데, 이가 지켜지지 않을 경우에는 자동적인 형 변환이 이루어진다.

    하나의 수식에서 서로 다른 자료형이 사용되면 모든 자료형은 그 중에서 가장 높은 등급의 자료형으로 자동적으로 변환된다. 그 이유는 데이터의 손실을 막기 위해서이다. 자료형의 등급을 순서대로 나열하면, int, unsigned int, long, unsigned long, float, double, long double 이다. 여기에서 char와 short는 이미 int로 변환되었기 때문에 생략한다.


### 명시적인 형 변환

지금까지의 형변환은 모두 자동적으로 이루어졌는데, 특정한 경우에는 명시적으로(직접) 형식을 변환하여야하는 경우도 있다.
이 때 사용하는 연산자가 형 변환 연산자(type cast)이다. 사용하기 위해선 원하는 자료형을 괄호 안에 넣고 상수나 변수 앞에 적어주면 된다.

> ex) (int) 123.123 >> 123
ex) (double) 123 >> 123.0

---

## 관계 연산자

이하 생략

---

## 논리 연산자

여러 개의 조건을 조합하여 참인지 거짓인지를 따질 때 사용한다.
&&(AND), 쉬프트 역슬래시 2개(OR), !(NOT) 으로 사용하면 된다.

주의할 점은 논리 연산자에서 0은 거짓, 0이 아닌값은 모두 참으로 인식하는 것이다.
그리고 논리 연산자의 출력값은 거짓이면 0, 참이면 1을 내보낸다!

---

## 조건 연산자

조건 연산자는 유일하게 3개의 피연산자를 갖는 삼항 연산자이다.

예를 들어서
> max_value = (x > y) ? x : y ;
는 x와 y 중에서 큰걸 변수에 넣는다는 것이다.

이렇게 조건 연산자를 사용가능하다.

---

## 콤마 연산자

보통 문장에서는 쉼표로 쓰이는 콤마가 연산자로도 사용된다. 수식을 콤마로 연결할 수 있으며 각각의 수식은 왼쪽부터 오른쪽으로 순차적으로 실행된다. 즉 한줄로 여러 함수들을 사용한다.

---

## 비트 단위 연산자

### 비트 연산자의 종류

|연산자|연산자의 의미|설명|
|---|---|---|
|&|비트 AND|두 개의 피연산자의 해당 비트가 모두 1이면 1, 아니면 0|
|쉬프트 역슬래시|비트 OR|두 개의 피연산자의 해당 비트 중 하나면 1이면 1, 아니면 0|
|^|비트 XOR|두개의 피연산자의 해당 비트의 값이 같으면 0, 아니면 1|
|<<|왼쪽으로 이동|지정된 개수만큼 모든 비트를 왼쪽으로 이동한다.|
|>>|오른쪽으로 이동|지정된 개수만큼 모든 비트를 오른쪽으로 이동한다.|
|~|비트 NOT|0은 1로 만들고 1은 0으로 만든다.|

비트 단위 연산자는 정수 타입의 피연산자에만 적용할 수 있다.

---

## 연산자의 우선 순위와 결합 규칙

히니의 수식이 2개 이상의 연산자를 가지고 있는 경우에는 연산자의 우선 순위에 따라 연산이 수행된다.

### 연산자들의 우선 순위

|우선 순위|연산자|결합 규칙|
|---|---|---|
|1|(), [], ->, ++(후위), --(후위)| 좌에서 우|
|2|sizeof(), &(주소), ++(전위), --(전위), ~, !, *(간접 참조), +(부호), -(부호), 형 변환|우에서 좌|
|3|*(곱셈), /, %|좌에서 우|
|4|+(덧셈), -(뺄셈)|좌에서 우|
|5|<<, >>|좌에서 우|
|6|<, <=, >, >=|좌에서 우|
|7|==, !=|좌에서 우|
|8|&(비트연산)|좌에서 우|
|9|^|좌에서 우|
|10|쉬프트 역슬래시|좌에서 우|
|11|&&|좌에서 우|
|12|쉬프트 역슬래시 2번|좌에서 우|
|13|?(삼항 연산자)|우에서 좌|
|14|=, +=, *=, /=, %=, &=, 등|우에서 좌|
|15|,(콤마)|좌에서 우로|

### 연산자들의 우선 순위를 일련으로 정렬하면

> 콤마, 대입, 논리, 관계, 산술, 단항

순서대로 우선순위가 커진다.

- 괄호 연산자는 가장 우선순위가 높다.
- 모든 단항 연산자들은 이항 연산자들보다 우선 순위가 높다. 예를들어서 ++ 연산자는 + 연산자보다 우선 순위가 높다.
- 콤마 연산자를 제외하고는 대입 연산자가 가장 우선순위가 낮다.




### 연산자들의 결합 규칙

만약 아래의 수식과 같이 동일한 우선 순위를 가지는 연산들이 여러 개가 있으면 어떤 것을 먼저 수행하여야 하는가?

> x * y * z

이 때는 연산자마다 달라지는데 산술 연산자의 경우에는 왼쪽에서 오른쪽으로 연산이 수행된다.  즉 x * y가 먼저 수행된다. 
이것이 연산자의 __결합 규칙__ 이다. 결합 규칙이란 동일한 우선 순위의 연산이 있는 경우 무엇을 먼저 수행하느냐에 대한 규칙이다.